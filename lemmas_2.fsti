val lemma_eucl_div_bound: a:int -> b:int -> q:int -> Lemma (requires (a < q)) (ensures  (a + q * b < q * (b+1)))
val lemma_mult_le_left: a:nat -> b:int -> c:int -> Lemma (requires (b <= c)) (ensures  ((op_Multiply a  b) <= (op_Multiply a c)))
val lemma_mult_le_right: a:nat -> b:int -> c:int -> Lemma (requires (b <= c)) (ensures  ((op_Multiply b a) <= (op_Multiply c a)))
val lemma_mult_lt_left: a:pos -> b:int -> c:int -> Lemma (requires (b < c)) (ensures  ((op_Multiply a b) < ((op_Multiply a c))))
val lemma_mult_lt_right: a:pos -> b:int -> c:int -> Lemma (requires (b < c)) (ensures  ((op_Multiply b a) < (op_Multiply c a)))
val swap_mul: a:int -> b:int -> Lemma ((op_Multiply a  b) = (op_Multiply b a))
val lemma_cancel_mul: (a:int) -> (b:int) -> (n : pos) -> Lemma (requires ((op_Multiply a n) = (op_Multiply b n))) (ensures (a = b))
val distributivity_add_left: a:int -> b:int -> c:int -> Lemma (( op_Multiply (a + b) c) = (op_Multiply a c) + (op_Multiply b c))
val distributivity_add_right: a:int -> b:int -> c:int -> Lemma (( op_Multiply a  (b + c)) = (op_Multiply a  b) + (op_Multiply a  c))
val pow2_double_sum: n:nat -> Lemma ((pow2 n) + (pow2 n) = (pow2 (n + 1)))
val pow2_double_mult: n:nat -> Lemma ((op_Multiply 2 (pow2 n)) = (pow2 (n + 1)))
val pow2_le_compat: n:nat -> m:nat -> Lemma (requires (m <= n)) (ensures  ((pow2 m) <= (pow2 n)))
val multiply_fractions: (a:int) -> (n:int {(n > 0 \/ n < 0)}) -> Lemma ((n * ( a / n ) <= a))
val small_div: (a:nat) -> (n:pos) -> Lemma (requires (a < n)) (ensures ((div a n) = 0))
val bounded_multiple_is_zero: (x:int) -> (n:pos) -> Lemma  (requires (-n < (op_Multiply x n) /\ ((op_Multiply x n) < n))) (ensures( x = 0))
val multiple_division_lemma: (a:int)-> (n:int {n > 0 \/ n < 0}) -> Lemma ((div (op_Multiply a n) n) = a)
val neg_mul_left: a:int -> b:int -> Lemma (-(op_Multiply a b) = (op_Multiply (-a) b))

val swap_neg_mul: a:int -> b:int -> Lemma ((op_Multiply (-a)  b) = (op_Multiply a (-b)))
val distributivity_sub_left: a:int -> b:int -> c:int -> Lemma ((op_Multiply (minus a b) c) = (op_Multiply a c) - (op_Multiply b c))
val distributivity_sub_right: a:int -> b:int -> c:int -> Lemma ((op_Multiply a (minus b c)) = (op_Multiply a b) - (op_Multiply a c))
val lemma_abs_mul : a:int -> b:int -> Lemma ((abs a) * (abs b) = (abs (a * b)))
val nat_over_pos_is_nat: a:nat -> b:pos -> Lemma ((div a b) >= 0)
val pow2_lt_compat: n:nat -> m:nat -> Lemma (requires (m < n)) (ensures  ((pow2 m) < (pow2 n)))
val pow2_le_compat: n:nat -> m:nat -> Lemma (requires (m <= n)) (ensures  ((pow2 m) <= (pow2 n)))
val pow2_plus: n:nat -> m:nat -> Lemma (((pow2 n) * (pow2 m) = (pow2 (n + m))))
val pow2_minus: (n:nat) -> (m:nat{ n >= m }) -> Lemma ((pow2 n) / (pow2 m) = (pow2 (minus n m)))
val lemma_div_lt_nat: (a:int) -> (n:nat) -> (m:nat{m <= n}) -> Lemma (requires (a < (pow2 n))) (ensures  (a / (pow2 m) < (pow2 (minus n m))))
val lemma_div_lt: (a:int) -> (n:nat) -> (m:nat) -> Lemma  (requires (m <= n /\ a < (pow2 n)))  (ensures (a / (pow2 m) < (pow2 (minus n m))))
val division_propriety: a:int -> b:pos -> Lemma ((minus a b) < (div a b) * b /\ (div a b) * b <= a)
val division_definition_lemma_1: a:int -> b:pos -> m:int{(minus a b) < m * b} ->  Lemma (m > (div a (minus b 1)))
val division_definition_lemma_2: a:int -> b:pos -> (m:int{(op_Multiply m  b) <= a}) -> Lemma (m < (div a b) + 1)
val division_definition: a:int -> b:pos -> m:int{(minus a b) < (m * b) /\ (m * b) <= a} -> Lemma (m = (div a b))
val lt_square_div_lt: (a:nat) -> (b:pos) -> Lemma (requires (a < (op_Multiply b b))) (ensures ((div a b) < b))